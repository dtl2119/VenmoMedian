#VenmoMedian
Calculating the rolling median degree of a graph generated by incoming Venmo Payments

###Project:
Build a graph using payments between Venmo users as edges.  The graph should
only consist of payments within a 60-second sliding time window -- any payments
outside of this window should be removed from the graph.  After each processed
payment, the graph is updated, and the median degree of all vertices should
be calculated.

Instead of using the Venmo API to stream payments, we will take an input file with
JSON messages where each line represents a transaction.


###Pre-built modules:
I tried to use as few modules as possible, though I did import a few:

* sys: used for command line args, and to exit on incorrect arguments
* json: to extract the 3 fields of the JSON message (created_time, actor, target)
* datetime: to convert the raw time format to a unix timestamp for easy comparisons

###Executing my program:
Once in the root of my VenmoMedian repo, you can just run the executable:
> ./run.sh

&nbsp;

This essentially runs my `rolling_median.py` python script in the src directory, with the input and output files as command line arguments:

> python ./src/rolling_median.py ./venmo_input/venmo-trans.txt ./venmo_output/output.txt


###Graph and data structures (and examples):
`edges` is a dictionary where the key is an edge (2-tuple: (person1, person2)) and the value is the timestamp of the payment between them:
`(Harry, John): 1460000098`

`times` is a dictionary where the key is a timestamp and the value is a list of all edges sharing that timestamp:
`timestamp: [(node1, node2), (node3, node4), … ]`

`degrees` is a dictionary where the key is a user/node and the value is how many degrees or connections that person has:
`Harry: 5`

`degreeList` is a list that is always kept sorted in reverse order, allowing quick median checks.  A payment involves 2 people,  so disregarding the time window, the most that can happen is only two numbers in this list change (and they can only increment by 1 at most).  I chose reverse order because incrementing the first occurrence of an integer by 1 in a decreasing int list, keeps the list sorted:

Example (increment the first 3): `[4,4,3,3,3,2,2,1] → [4,4,4,3,3,2,2,1]`


###NOTES:
* I assumed that the actor and target fields are unique and case sensitive.

* I decided to keep the input and output files open until we reached the end of input.  I did this because constantly opening/closing the output file and appending the median significantly increased run time.  The downside is that nothing gets written to the output file until the script completes.  This is not a real world situation, as usually we’d be streaming input.  Therefore, if we want to stream and continuously append to the output file, we can uncomment L98 and L151 (and remove the lines before them).
